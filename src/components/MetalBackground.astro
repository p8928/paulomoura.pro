---
// Importa as dependências necessárias
import * as THREE from 'three';
---

<div id="metalBackground" class="metal-background"></div>

<script>
  // Código client-side para Three.js
  if (typeof window !== 'undefined') {
    // Inicializa a cena Three.js
    const scene = new THREE.Scene();
    
    // Configura a câmera
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 5;
    
    // Configura o renderizador
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    
    // Adiciona o renderizador ao elemento
    document.getElementById('metalBackground').appendChild(renderer.domElement);
    
    // Cria uma geometria para o background
    const geometry = new THREE.SphereGeometry(20, 128, 128);
    
    // Cria um material metálico com propriedades avançadas
    const material = new THREE.MeshPhysicalMaterial({
      color: new THREE.Color(0.8, 0.1, 0.1), // Vermelho Ferrari
      metalness: 1.0,
      roughness: 0.0,
      clearcoat: 1.0,
      clearcoatRoughness: 0.0,
      reflectivity: 1.0,
      envMapIntensity: 2.0,
      side: THREE.DoubleSide
    });
    
    // Cria o mesh e adiciona à cena
    const metalSphere = new THREE.Mesh(geometry, material);
    scene.add(metalSphere);
    
    // Cria um plano para o efeito de aço escovado
    const planeGeometry = new THREE.PlaneGeometry(100, 100);
    
    // Cria um material shader para o efeito de aço escovado
    const brushMaterial = new THREE.ShaderMaterial({
      uniforms: {
        time: { value: 0 },
        resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) }
      },
      vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform float time;
        uniform vec2 resolution;
        varying vec2 vUv;
        
        void main() {
          // Coordenadas normalizadas
          vec2 uv = vUv;
          
          // Cria linhas verticais para simular aço escovado
          float frequency = 1500.0; // Número de linhas (aumentado)
          float lineWidth = 0.015; // Espessura das linhas (reduzido)
          float line = smoothstep(0.5 - lineWidth, 0.5 + lineWidth, 
                        sin(uv.x * frequency + time * 0.5) * 0.5 + 0.5);
          
          // Adiciona variação na intensidade das linhas
          float variation = sin(uv.y * 25.0 + time) * 0.015 + 0.985;
          
          // Cor base metálica (vermelho Ferrari)
          vec3 baseColor = vec3(0.8, 0.1, 0.1);
          
          // Cores para as linhas (brilho e sombra)
          vec3 brightColor = vec3(1.0, 0.6, 0.6); // Mais brilhante
          vec3 darkColor = vec3(0.3, 0.0, 0.0);   // Mais escuro
          
          // Aplica o efeito de aço escovado
          vec3 color = mix(darkColor, brightColor, line) * variation;
          
          // Adiciona brilho especular mais intenso
          float specular = pow(line, 8.0) * 2.0;
          color += vec3(specular);
          
          gl_FragColor = vec4(color, 0.7); // Transparência ajustada
        }
      `,
      transparent: true,
      blending: THREE.AdditiveBlending
    });
    
    // Cria o mesh do plano e adiciona à cena
    const brushPlane = new THREE.Mesh(planeGeometry, brushMaterial);
    brushPlane.position.z = -5; // Posiciona atrás da esfera
    scene.add(brushPlane);
    
    // Adiciona luzes para efeitos realistas
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
    scene.add(ambientLight);
    
    const directionalLight1 = new THREE.DirectionalLight(0xff0000, 3);
    directionalLight1.position.set(10, 10, 10);
    scene.add(directionalLight1);
    
    const directionalLight2 = new THREE.DirectionalLight(0x0000ff, 2);
    directionalLight2.position.set(-10, -10, -10);
    scene.add(directionalLight2);
    
    const pointLight1 = new THREE.PointLight(0xff4444, 2);
    pointLight1.position.set(15, 15, 15);
    scene.add(pointLight1);
    
    const pointLight2 = new THREE.PointLight(0x4444ff, 1.5);
    pointLight2.position.set(-15, -15, -15);
    scene.add(pointLight2);
    
    // Função de animação com GSAP
    function animate() {
      requestAnimationFrame(animate);
      
      // Atualiza o tempo no shader
      brushMaterial.uniforms.time.value += 0.01;
      
      // Animações da esfera metálica com GSAP
      if (typeof window.gsap !== 'undefined') {
        gsap.to(metalSphere.rotation, {
          x: metalSphere.rotation.x + 0.003,
          y: metalSphere.rotation.y + 0.004,
          duration: 1,
          ease: "none"
        });
      } else {
        // Fallback caso GSAP não esteja disponível
        metalSphere.rotation.x += 0.003;
        metalSphere.rotation.y += 0.004;
      }
      
      renderer.render(scene, camera);
    }
    
    // Inicia a animação
    animate();
    
    // Ajusta o tamanho ao redimensionar a janela
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      
      // Atualiza a resolução no shader
      brushMaterial.uniforms.resolution.value.set(window.innerWidth, window.innerHeight);
    });
  }
</script>

<style>
  .metal-background {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 1; /* Ajustado para ficar acima do body */
    /* Adiciona filtros CSS para sombras e luz equilibradas */
    filter: brightness(1.4) contrast(1.3) saturate(1.4) drop-shadow(0 0 15px rgba(0, 0, 0, 0.6));
  }
</style>