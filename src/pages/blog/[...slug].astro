---
import { getCollection } from 'astro:content';
import BlogPost from '../../components/blog/BlogPost.astro';
import TableOfContents from '../../components/blog/TableOfContents.astro';

export async function getStaticPaths() {
  const blogPosts = await getCollection('blog');
  return blogPosts.map(post => ({
    params: { slug: post.slug },
    props: { post }
  }));
}

// Obter o slug do parâmetro de rota
const { slug } = Astro.params;

// Obter a coleção de posts do blog
const blogPosts = await getCollection('blog');
const post = blogPosts.find(p => p.slug === slug);

// Obter posts relacionados com base nas tags
const relatedPosts = blogPosts
  .filter(p => 
    p.data.tags.some((tag: string) => post?.data.tags.includes(tag)) && 
    p.slug !== post?.slug
  )
  .slice(0, 3); // Pegar até 3 posts relacionados

// Extract headings from the post body to generate table of contents
// In a real implementation, you'd parse the markdown to extract headings
// For now, we'll leave the TOC empty, but each markdown file could include its own TOC
---

{post ? 
  <BlogPost post={post} relatedPosts={relatedPosts}>
    <div class="post-content" slot="content">
      <article set:html={post.body} />
    </div>
    <TableOfContents slot="toc">
      <!-- This would be populated with actual TOC items based on the content's headings -->
      <!-- For now, it's empty, but the structure is available -->
    </TableOfContents>
  </BlogPost>
  : <p>Post não encontrado</p>
}